<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="Most of the productivity gains from AI and other DevTools of the past decade have not made their way to the engineers working on large, mature codebases. If we want to make our biggest companies more productive we need a better system of record for the engineering org."><meta name="generator" content="Astro v5.16.0"><title>AI Hasn&#39;t Helped Most Engineers (yet) - Oliver Gilan</title><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="stylesheet" href="/_astro/_slug_.CH1yTI4v.css"></head> <body> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="29kQRR" prefix="r2" component-url="/_astro/Header.Cthuew7X.js" component-export="Header" renderer-url="/_astro/client.Ck_OXNAA.js" props="{&quot;currentPath&quot;:[0,&quot;/blog/ai-hasnt-helped-most-engineers&quot;]}" ssr client="load" opts="{&quot;name&quot;:&quot;Header&quot;,&quot;value&quot;:true}" await-children><header class="border-b border-gray-200 mb-8"><nav class="max-w-4xl mx-auto px-4 py-6"><div class="flex items-center justify-between"><a href="/" class="text-2xl font-bold text-gray-900 hover:text-gray-700">Oliver Gilan</a><ul class="flex items-center gap-6"><li><a href="/" class="flex items-center gap-1 text-sm font-medium transition-colors text-gray-600 hover:text-gray-900">Home</a></li><li><a href="/blog" class="flex items-center gap-1 text-sm font-medium transition-colors text-gray-600 hover:text-gray-900">Blog</a></li><li><a href="/stream" class="flex items-center gap-1 text-sm font-medium transition-colors text-gray-600 hover:text-gray-900">Stream</a></li><li><a href="/blogroll" class="flex items-center gap-1 text-sm font-medium transition-colors text-gray-600 hover:text-gray-900">Blogroll</a></li><li><a href="/books" class="flex items-center gap-1 text-sm font-medium transition-colors text-gray-600 hover:text-gray-900">Books</a></li><li><a href="/rss.xml" class="flex items-center gap-1 text-sm font-medium transition-colors text-gray-600 hover:text-gray-900"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg>RSS</a></li></ul></div></nav></header><!--astro:end--></astro-island> <main class="max-w-4xl mx-auto px-4 py-8">  <article> <header class="mb-8"> <h1 class="text-4xl font-bold mb-4">AI Hasn&#39;t Helped Most Engineers (yet)</h1> <time class="text-gray-600">December 18, 2024</time> </header> <div class="prose prose-lg max-w-none"> <p>The <a href="https://en.wikipedia.org/wiki/Lockheed_Martin_F-35_Lightning_II">F-35</a> is one of the most advanced man-made machines ever created. It can fly at 1.6x the speed of sound, is virtually undetectable by radar, can hover in place, and provides a total 360-degree field of view to the pilot.</p>
<p>It’s a marvel of human achievement, but it’s constantly plagued by <a href="https://www.reuters.com/business/aerospace-defense/us-resumes-taking-f-35-after-delays-over-software-upgrade-2024-07-20/">delays and cost overruns</a>. A common source of the issues? Software.</p>
<blockquote>
<p><em>“The hardware of [<a href="https://www.lockheedmartin.com/en-us/news/statements-speeches/2024/lockheed-martin-update-on-f-35-technology-refresh-3.html">Technology Refresh-3</a>] seems to be coming along fine but the software is lagging,”</em></p>
<p><em>— Secretary of the Air Force Frank Kendall</em></p>
</blockquote>
<p><strong>How can it be that the most advanced machine on earth is delayed because of software?</strong> How is it that, time and time again, it’s harder for companies to write competent code than it is to literally fly humans faster than the speed of sound?</p>
<p>This is the epitome of the <a href="https://olivergilan.com/blog/software-crisis/">Software Crisis</a>.</p>
<p><em>Despite all intuition to the contrary, it appears to be harder for us as a civilization to build in the world of bits than in the world of atoms.</em></p>
<p>And, most of our progress in developer tooling and AI hasn’t done much to change this. It’s not like there hasn’t been progress in developer tooling. It’s never been easier to start a project and go from 0 to 1 — a solo developer can spin up new projects faster than ever with AI-powered text editors, robust UI libraries, one-click deploys, auth in a box, and Stripe — but none of those productivity gains have made their way to teams working in big companies.</p>
<p>The senior engineer working on a 10-year-old codebase at a Fortune-50 insurance company or the engineer writing software for our nation’s military is stuck in an unproductive past.</p>
<p>Our DMVs need software. Our financial institutions need software. Our cars and planes need software. Our schools need software. Our farms need software. Our logistics companies need software. We’ll only see the AI’s full impact on technology and society when we can find a way to drive productivity for engineers working on these kinds of large, mature codebases.</p>
<h2 id="how-we-got-here">How We Got Here</h2>
<p><strong>The software development lifecycle happens across the local development environment, repository environment, and runtime environment.</strong></p>
<p>Most of the last decade’s developer tools fall into the first layer: new JavaScript frameworks, terminal emulators, text editors powered by AI, code-gen chatbots, and more.</p>
<p>Tools like <a href="https://v0.dev/">Vercel’s v0</a> can help create complex user interfaces with AI (which is great if you’re working on a greenfield project using NextJS) but a principal engineer at a company like Chase Bank does not build new UIs often — let alone with a framework like NextJS. They probably just finished a multi-year project to upgrade some COBOL service to use Java 8, which they’ll be sticking with for another decade (at least). Tooling in the first layer makes for great demos, but it often doesn’t help engineers working on mature systems.</p>
<p><strong>A senior engineer working in a big company usually spends way less time writing code and way more time managing a living codebase:</strong> reviewing code, responding to outages, maintaining code quality, focusing on architecture, keeping dependencies up-to-date, optimizing hot paths, engaging in large-scale refactors/migrations, and overcoming coordination problems throughout the org. We need DevTools to make this type of work 10x easier.</p>
<p>Some of this work has been improved by developer tooling in the third layer (with the Cloud, observability platforms, infrastructure-as-code, etc), but, frankly, it hasn’t changed enough (partly because of hyperscalers’ complexity and the fragmented ecosystem of complementary tools). This layer has had less impact on productivity than one would expect.</p>
<p>In other words, we need a lot more innovation in the second layer of development — the repository. <strong>The repository is the canonical source of truth and the common denominator for an engineering organization.</strong> It’s where code changes are reviewed, issues discussed and prioritized, deployments orchestrated, dependencies managed, and where most of the work on a mature codebase is done. We need to make the repository itself far more powerful than it is today if we want to significantly improve the productivity of engineers managing large codebases.</p>
<h2 id="the-repository-as-a-living-codebase">The Repository as a Living Codebase</h2>
<p><strong>Today, the moment a line of code gets merged into production, it begins to rot.</strong> We don’t think about this much when building greenfield or hobby projects but when you’re working in a legacy codebase, you feel this pain. Every line of code has a maintenance burden and a debt associated with it. Senior engineers are paid to suffer with this.</p>
<p>Consider the engineer who needs to upgrade Java versions or update a dependency to get the latest security updates. Or the senior engineer called in to fix a flaky CI test when no one else can. These problems don’t affect greenfield projects, but they almost universally eat up significant time in any mature codebase.</p>
<p>Repositories should be full of agents working constantly in the background, analyzing the codebase and all of its activity while opening up PRs that address most of the maintenance work. They should scan codebases for known bad patterns and write fixes for them. They should find outdated dependencies or ones with security updates and do the work to update them and handle any necessary refactors. If there’s a need to migrate Java versions or migrate a service from one language to another or break up a monolith, agents should help plan (and implement!) the changes.</p>
<p><strong>Repositories should be alive by default.</strong> Code shouldn’t fall into disrepair simply due to time.</p>
<h2 id="reducing-toil">Reducing Toil</h2>
<p>Sometimes working on a mature codebase is slow because the problems are hard and sometimes it’s slow because there’s just so much <em>toil.</em> There’s so much toil in the average enterprise codebase that most engineers have <a href="https://paulgraham.com/schlep.html">schlep blindness</a> to their daily work.</p>
<p>I’ve been on teams where CI times took nearly an hour and then we started having flaky tests so it was common to wait 40 minutes to merge a PR only to have the test suite fail and require a re-run. Sometimes the toil is simply trying to download the context of a big PR so that you can review it effectively while navigating through a sea of formatting changes and other noise unrelated to the core changes in the PR. Enforcing smaller, <a href="https://www.stacking.dev/">stacked PRs</a>, can help the reviewer but that often just shifts the toil onto the author to find the right pieces to pull out of a branch into another, rewrite commits, etc. If you’re an open source maintainer your toil probably involves managing the inflow of user-submitted Issues, prioritizing real problems, filtering out duplicates, labeling issues correctly. Sometimes the toil is simply co-ordination related and not knowing who to assign to a PR whether that means finding the person on your team with the most bandwidth or finding an appropriate person to tag from a sister team.</p>
<p>In the same way that the repository should be intelligent enough to help maintain a codebase the repository plays a critical role in reducing toil when working collaboratively on a team. The repository should have agents identifying and fixes flaky CI tests, optimizing CI times, and improving test coverage. It should be dead simple to split up large PRs into smaller separate PR stacks that can be reviewed faster (it should even detect formatting or irrelevant changes and offer to automatically extract those into a separate PR). It should have agents suggesting fixes automatically for any nitpick comment so the author can just one-click approve them. It should be easy to automatically route PRs to the teammate with the smallest current workload (which can be determined a number of ways) or tag the most relevant engineers to review specific files. It should flag potential duplicate Issues, help label and triage them, and even solve small Issues when possible. It should summarize long discussion chains on contentious Issues, highlighting proposed solutions and important points from each side, so maintainers can stay caught up easier. It should reduce toil around communication overhead by presenting an intelligent Inbox so it’s always clear what PRs are blocked on your review, which Issues are the most contentious, what tests cases are flaking the most, what parts of the codebase are causing the most error logs, etc.</p>
<p>Most codebases are large interdependent systems with complex state that can behave in unexpected ways. The repository should be smart enough to recognize these moving pieces and reduce the toil that naturally arises from it so that engineers can spend more of their time on the interesting problems they were hired to solve.</p>
<h2 id="the-repository-as-the-system-of-record">The Repository as the System of Record</h2>
<p>The repository layer is more than just the lines of code in text files. <strong>It’s a system of record that operates across all the different codebases in an organization, enforcing team processes, facilitating co-ordination, and serving as the source of truth for the various services and products being built and operated.</strong></p>
<p>To be maximally effective, the repository needs to have context of far more than just the code. It should be aware of the issue management system and its work items, team compositions, code ownership, CI pipelines, deployment environments, and other external systems that eventually derive their behavior from the codebase.</p>
<p>GitHub, the leader in the space, only has a faint concept of different deployment environments and repository secrets. It doesn’t have any understanding of feature flags or other configuration options that might affect a program when it runs. Only open-source projects use GitHub Issues to manage their work items and most people use external services that add weak integrations to GitHub themselves. Its CI platform is a bunch of untyped YAML actions <a href="https://cycode.com/blog/github-actions-vulnerabilities/">riddled with security vulnerabilities</a> that aren’t easy to test or debug and even simple pipelines workflows like staged rollouts or rollbacks can be a pain to implement. Despite the common case of microservices it has no concept of multi-repository PRs or Issues and co-ordinating across team and codebase can often be a real challenge.</p>
<p>The more parts of the software development cycle that can be version controlled and meaningfully tied into the repository with deep linking the more effective automation can be. If tickets originate in the repository instead of being linked to PRs once they’re done then an intelligent repository could plan and scaffold an implementation. If feature flags and environment variables are version controlled you could more easily track down the cause of bugs that may not correlate with recent commits. If infrastructure footprints are linked to the repository it becomes easier to generate and optimize deployment pipelines.</p>
<p>I don’t believe the only solution is to rebuild all of these products internally but instead, a successor to GitHub will need to be proactive about building integrations with the surrounding ecosystem instead of waiting for everyone to integrate with it. It’ll have workflows and connectors designed to pull in data from other tools so that all the context of a living codebase can be tied back and version controlled effectively. In doing so the repository can finally become the proper system of record engineering teams need.</p>
<h2 id="the-next-generation-of-repositories">The Next Generation of Repositories</h2>
<p><strong>The company that solves those problems laid out above will look a lot like GitHub, just better in every way. It’ll have a lot of the same primitives: pull requests, issues, CI, etc. but every part of it will be <em>smarter.</em></strong></p>
<p>Pull requests will be simplified, stacked, and cleaned up by agents before a human reviews them. Issues will be triaged, categorized, and de-duplicated before a maintainer has to look at them. In some cases an agent will even open a PR to solve an Issue on its own. The repositories will have a concept of linking and pull requests, Issues, and CI runs will be able to span multiple repos for various workflows. Environment variables and secrets will be completely manageable alongside the repository with versioning and branching support. 2-way sync will enable local-first realtime collaboration for every part of the platform so that engineers are empowered to work on things synchronously and improve feedback cycles. It’ll integrate with local environments to enable fully reproducible development environments that can be spun up and collaborated on for specific features or changes. Complex git operations that allow you to maintain a clean history will be made easy and even root causing errors will be simplified. Agents will constantly scan codebases to find bad patterns or outdated dependencies and resolve them. Long running initiatives like refactors will be spearheaded and augmented by agents working in realtime with human engineers. I predict agents will even be able to ingest logs to update repository linting rules and best practices to help eliminate classes of bugs that repeatedly appear. <em>Nearly every part of the platform will be extensible via built-in and custom agents.</em></p>
<p><strong>Mesa is building towards this future and if that excites you please reach out.</strong> Realizing this vision means tackling a variety of technical challenges such as building RAG systems to power intelligence on multiple codebases with current SOTA models, backend systems design to build low-latency scalable git servers, sync engines for performant local-first clients with realtime collaboration, and product design so that a highly technical product can be both approachable and easy to use while containing depth of functionality.</p>
<p>If any of these problems excite you, and you want to change the way massive teams build software you can reach me at <a href="mailto:oliver@mesa.dev">oliver@mesa.dev</a></p> </div> </article>  </main> <footer class="border-t border-gray-200 mt-12"><div class="max-w-4xl mx-auto px-4 py-8"><div class="flex flex-col items-center gap-4"><p class="text-sm text-gray-600">© <!-- -->2025<!-- --> Oliver Gilan</p></div></div></footer> </body></html>